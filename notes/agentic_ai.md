***Day 2 - Agentic AI***

**Agent**
- An agent is a system that:
    - Receives a goal
    - Decides what action to take
    - Executes actions in an environment
    - Observes results
    - Adjusts behavior based on those results.

    And repeats until the goal is achieved.

- If we use User -> LLM -> Output; then it is one shot reasoning
- But if we do User -> LLM -> Tool -> LLM -> Tool -> LLM -> Output; that is iterative decision making
- There are 4 phases in an agentic workflow. Plan -> Act -> Observe -> Reflect

**Plan**
- This is where the model decided what to do next.
- There is no execution during this phase.

**Act**
- This is where the model does the actual work or executes the chosen tool.
- This action happens outside the LLM.
- This action is done by the system, because the LLMs are probabilistic and untrusted; and the system is deterministic and controlled

**Observe**
- This is the step where the agent introspects the output generated by the tool.
- Without an observation step, the agent cannot evaluate whether its action moved it closer to the goal.

**Reflect**
- The model reasons again using the updated state.
- This step prevents blind re execution chains.


**Real world example of Agentic AI workflow**
- Plan: "There is an error in the code; I need to check the logs"
- Act: "Opens the logs"
- Observe: "Finds the error"
- Reflect: "ZeroDivision Error"


**Why the control should remain with the system rather than the LLM in *act* phase?**
- The systems are controlled and deterministic while the LLMs are uncontrolled and probabilistic.
- Systems can validate 
    - Validate tool name (whitelist): The system can check the agent is allowed to use the tool or not.
    - Validate arguments (JSON schema): The system can check if the info that the AI sends is structured or not.
    - Enforce permissions: Systems can override requests of the LLMs to use restricted tools
    - Enforce timeouts: The system can choose to stop the agent in case of repeated LLM calls, system overload etc
-----------------------------


Workflows are static and pre-defined, whereas agents dynamically determine the next action based on state, memory, and observed outcomes. This allows adaptive behavior but introduces control challenges.

**Tools**
- In agentic AI, tools are external capabilities the agent can use to act in the world.
- If the LLM is the brain, then the tools are its hands and legs(the actual body parts which properly execute an action)

**State**
- The situation the agent currently is in. 
- It includes the task, the environment, what has already occurred, the next steps in the pipeline 

**Memory**
- The things the agent remembers over time.
- There are usually two types:
    - Short-term memory
        - What happened in this session
        - Conversation history
        - Intermediate reasoning
    - Long-term memory
        - User preferences
        - Past interactions
        - Learned patterns
        - Stored documents

**Constraints**
- The rules that limit what the agent can accomplish.
- They are in place to prevent unruly behaviours by the agents.
- Constraints are particularly important in financial agents, where spending limits (e.g., a maximum of 500 INR) must be enforced.

There are various safety measures in place which can restrict the agents. They are 

**Sandboxing**
- It is a practice in which the agent along with its tools are run in an isolated, restricted environment.
- This is done to ensure security and safety of critical data, so in case something happens, the critical data is safe

**Tool permissions**
- These are the permissions given to the agent that define how the agent can use a particular tool.
- These permissions are critical components of the agentâ€™s safety layer.

**Retries**
- Basically the system tries to do something if it fails.
- Retries make the agent more robust and reliable.
- But one more important detail:
    - Retries must be controlled or else we could run into
        - Infinite loops
        - Duplicate Charges
        - increased operational costs

**Timeouts**
- Timeouts stop an action if it runs too long.
- These are helpful to cut costs if the action is taking too long to execute
- Prevents:
    - Infinite loops
    - resource exhaustion
    - Stuck Processes
    - Also helps save time; which could have otherwise been wasted

